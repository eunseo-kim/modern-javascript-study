# Chapter11-(8). 마이크로태스크 큐

### 📌용어 정리 먼저!

- 매크로 태스크 큐 == 태스크 큐
- 마이크로 태스크 큐 == PromiseJobs 큐

> 이제부터는 `태스크 큐`, `마이크로태스크 큐`로 부를 예정👏🏻

---

## 🔍출력 순서 이해하기

- 다음 코드의 출력 결과를 예측해보자!

  ```js
  setTimeout(function() { 			// (A) 0초 후(?) console.log('A') 실행
      console.log('A');
  }, 0);
  Promise.resolve().then(function() { // (B)
      console.log('B');
  }).then(function() { 				// (C)
      console.log('C');
  });
  ```

  > ### 정답
  >
  > ```
  > B
  > C
  > A
  > ```

- 이유가 뭘까?😨😨  `A => B => C` 처럼 동작할 줄 알았는데..!
  ✨바로 **마이크로태스크 큐와 태스크 큐**의 차이점 때문이다.

- 쉽게 말해서,

  ### 마이크로 태스크는 태스크보다 더 높은 우선순위를 갖는 태스크이다

- 그리고,

  ### 프로미스는 마이크로태스크를 사용한다.

  

📌이 2가지를 기억하면서 (A), (B), (C)가 각각 마이크로태스크, 태스크 중 어디에 저장되는지 알아보자.

> - 우선, `setTimeout`은 자신의 콜백 함수인 (A)를 **태스크 큐**에 추가한다.
  그러나 **프로미스**의 `then`은 자신의 콜백 함수 (B), (C)를 **마이크로태스크 큐**에 저장한다.
  - 그 다음에 **이벤트 루프**는 Call Stack이 비면, 먼저 **마이크로태스크 큐**에서 대기하고 있는 함수(B), (C)를 차례대로 가져와 실행한다.
  - 이후 마이크로태스크 큐가 비게 되면, **태스크 큐에서 대기하고 있는 함수를 가져와** 실행한다.



## 🔍(Javascript.info 예시) 예시 하나 더! 풀어보기

```js
let promise = Promise.resolve();			// (1)

promise.then(() => alert("프라미스 성공!"));	// (2) 

alert("코드 종료");							  // (3)
```

> ## 출력
>
> 코드 종료
>
> 프라미스 성공!

### 📌실행 순서

1. (1), (2), (3) 차례대로 코드를 실행한다.
2. 단, (2)에 도달했을 때...
   바로 `alert`를 실행하는 것이 아니라, `then`의 콜백 함수를 **마이크로태스크 큐**에 넣어둔다.
3. 반면 (3)의 `alert("코드 종료")`는 그냥 동기적으로 처리되는 함수이므로 바로 출력한다.
4. (1)~(3) 모든 코드를 실행하고 Call Stack이 비어있는 것을 확인한다면,
5. 마이크로태스크 큐에 있는 모든 작업을 차례대로 수행한다. 이때 (2)에서 넣어둔 `alert("프라미스 성공!")`이 출력된다.
6. 마이크로태스크 큐를 모두 비우면 태스크 큐에 있는 것들을 실행한다.(위의 예시에서는 없다.)



![](https://uploads.disquscdn.com/images/9466d8aa53fc5b3e63a92858a94bb429df02bbd20012b738f0461343beaa6f90.gif?w=600&h=350)



---

> 💡**참고할만한 좋은 글** → [자바스크립트와 이벤트 루프] https://meetup.toast.com/posts/89

